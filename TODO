Copyright (C) 2009 by Ashley J. Wilson and Roger E. Ostrander.
This software is licensed as described in the file COPYING in the root directory
of this distribution.

A rough timeline of the tasks to finish before we see release, large and small.

# Environment and Data Structures

* An LRU cache for objects to live in while resident in memory.
* error handling and reporting system.
* include a logging system.
- make the SConstruct files a little more cross-platform.
* obl_database struct (a place for the cache, logger, and error handlers to
   live).
* the rest of the obl_object internal format structs.
* manual creation functions for obl_shape objects.
= conversion functions from C data types to obl_object types.
   remaining: chunk; float; double; char
* obl_at_address should hit fixed space and the cache.

# Primitive I/O

* implement mmap() and munmap() equivalents for MinGW.
= read/ = write the single-word object formats:
   remaining: rw float; rw double; rw char
* read/ * write string objects.
* read/ * write slotted objects.
* read/ * write fixed objects.
- read/ - write chunks.
* read/ * write tree pages.
* read/ * write shape objects.
* read/ * write arbitrary objects by reading the shape word and delegating to one
   of the other object-reading functions.
= proper handling of read depth and stubbing.
* implement the address map with tree pages.
* implement the address allocator.
* obl_address_at should use the address mapper and read functions.
* bootstrap new obl_databases by writing the root object.
- bounds-checking within storage/ functions.
- make the shape of a shape another shape.
- printstrings for objects.
* split object.h into a difference source file for each storage type
- write accessors and mutators for storage structs
- combine "create"/"open" and "destroy"/"close" operations.  possibly create
   with an open configuration struct?
- give obl_database an indirect reference to the database file to hide things
   like remappings.
= doxygen it up.

# Advanced I/O

- use a heap-based physical address allocator.
- write the transaction mechanism.
- manage a read set and a write set instead of the LRU cache.
- use the read and write sets for actual cleanup of garbage.
- implement a cross-platform semaphore wrapper.  manage access to the read and
   write sets, transaction commits, and other critical resources.

# Compound object interfaces

- implement the index object, probably as a generalization of the B+ tree
   address map.
- design high-level set and dictionary interfaces that use indices to organize
   references to other objects.
- write the shape index.

# Binding for VisualWorks Smalltalk

# Binding for Ruby

# Version 1.0 Release